--- 
title: Ch.27 資料庫 API
tags:
 - MongoDB
 - Node.js
prev: ./ch26
next: ./ch28
---
製作能增改刪查資料庫的網頁 API，並熟悉 export 和 import
<!-- more -->

## 前置作業
### 安裝套件
  ```js
  // MongoDB 操作套件
  npm install mongoose
  // Mongoose 資料重複驗證錯誤訊息插件
  npm install mongoose-beautiful-unique-validation
  // 將 _id 欄位顯示為 id 的插件
  npm install mongoose-id
  // 驗證
  npm install validator
  // 網頁伺服器
  npm install express
  // 讀取傳入網頁伺服器的資料
  npm install body-parser
  // express 允許跨域請求
  npm install cors
  // 讀取環境設定檔
  npm install dotenv
  // MD5 加密套件
  npm install md5
  ```

### 設定資料庫綱要
建立 `database.js`，將資料庫設定與主體分開寫  
使用 Mongoose 時必須要建立資料庫綱要 Schema  
Mongoose 的資料庫綱要除了能保持資料格式一致，也可以做資料驗證  
```js
// 引用驗證工具
import validator from 'validator'
// 引用 mongoose
import mongoose from 'mongoose'
// 引用 dotenv
import dotenv from 'dotenv'
// 引用重複驗證錯誤訊息插件
import beautifyUnique from 'mongoose-beautiful-unique-validation'
// 引用將 _id 欄位顯示為 id 的插件
import idPlugin from 'mongoose-id'

dotenv.config()
const Schema = mongoose.Schema

// 連接資料庫
mongoose.connect(process.env.dbUrl, { useNewUrlParser: true, useUnifiedTopology: true })

// 引用插件
mongoose.plugin(beautifyUnique)
mongoose.plugin(idPlugin)

// 編寫資料表綱要
const userSchema = new Schema(
  {
    // 欄位名稱
    name: { 
      // 資料類型是文字
      type: String,
      // 最小長度，自訂錯誤訊息 
      minlength: [4, '使用者名稱最小 4 個字'],
      // 最大長度，自訂錯誤訊息
      maxlength: [12, '使用者名稱最大 12 個字'],
      // 必填欄位，自訂錯誤訊息
      required: [true, '使用者名稱必填'],
      // 避免重複，只能設定 true，無法自訂錯誤訊息，除非使用插件
      unique: '使用者名稱重複'
    },
    password: { 
      type: String, 
      required: [true, '密碼必填'],
    },
    age: {
      type: Number,
      // 最小值，自訂錯誤訊息
      min: [18, '必須大於 18 歲'],
      // 最大值，自訂錯誤訊息
      max: [99, '請輸入有效年齡'],
      required: [true, '年齡必填'],
    },
    email: {
      type: String,
      required: [true, '信箱必填'],
      unique: '信箱已使用',
      // 自訂驗證規則
      validate: {
        // 驗證 function
        validator (value) {
          return validator.isEmail(value)
        },
        // 錯誤訊息
        message: '信箱格式錯誤'
      }
    },
  }, 
  {
    // 不要紀錄資料修改次數
    versionKey: false
  }
)

// 建立 Model
// mongoose.model('資料表名稱', Schema)
// 資料表名稱必須為複數，結尾加 s
const users = mongoose.model('users', userSchema)

// 匯出變數
export default {
  users
}
```

### 網頁伺服器
建立 `index.js`，設定 express 網頁伺服器
```js
// 網頁伺服器
import express from 'express'
// 讓 express 可以讀取 Body 資料
import bodyParser from 'body-parser'
// 跨域套件
import cors from 'cors'
// MD5 加密
import md5 from 'md5'
// 資料庫檔案
import db from './db.js'

const app = express()

// 讓 express 使用 body-parser，並把收到的資料轉 json
app.use(bodyParser.json())

// 設定跨域套件
app.use(cors({
  // origin 為請求來源網域, callback 為是否允許的回應
  origin (origin, callback) {
    // 允許任何來源網域的請求
    callback(null, true)
    // 若要拒絕請求則是
    // callback(new Error('cors error'), false)
  },
  // 允許跨域認證
  credentials: true
}))

// 啟動網頁伺服器
app.listen(3000, () => {
  console.log('網頁伺服器已啟動')
  console.log('http://localhost:3000')
})
```

## 製作 API
### 新增
新增使用者資料  
```js
// 請求方式為 POST，路徑為 /users
// 後面的 function 可以為 async
app.post('/users', async (req, res) => {
  // 拒絕不是 json 的資料格式
  if (!req.headers['content-type'].includes('application/json')) {
    // 回傳錯誤狀態碼
    res.status(400)
    res.send({ success: false, message: '格式不符' })
    return
  }

  // 新增資料
  try {
    const result = await db.users.create(
      {
        name: req.body.name,
        password: md5(req.body.password),
        age: req.body.age,
        email: req.body.email
      }
    )
    res.status(200)
    res.send({
      success: true,
      message: '',
      id: result.id,
      name: result.name,
      age: result.age,
      email: result.email
    })
  } catch (error) {
    // 資料格式錯誤
    if (error.name === 'ValidationError') {
      // 錯誤的訊息的 key 值為欄位名稱，不固定
      // 所以用 Object.keys(err.errors)[0] 取得第一個 key 值
      const key = Object.keys(error.errors)[0]
      const message = error.errors[key].message
      res.status(400)
      res.send({ success: false, message })
    } else {
      res.status(500)
      res.send({ success: false, message: '伺服器發生錯誤' })
      console.log(error)
    }
  }
})
```

### 查詢
查詢所有使用者  
```js
app.get('/users', async (req, res) => {
  try {
    const result = await db.users.find({}, '-password')
    res.status(200)
    res.send({ success: true, message: '', users: result })
  } catch (error) {
    console.log(error.message)
    res.status(500)
    res.send({ success: false, message: '伺服器發生錯誤' })
  }
})
```

以 ID 查詢單個使用者  
```js
app.get('/users/:id', async (req, res) => {
  try {
    // 使用 id 尋找資料，只取 account，去掉 id
    const result = await db.users.findById(req.params.id)
    res.status(200)
    res.send({
      success: true,
      message: '',
      id: result.id,
      name: result.name,
      age: result.age,
      email: result.email
    })
  } catch (error) {
    // 若 ID 格式不是 mongodb 格式
    if (error.name === 'CastError') {
      res.status(404)
      res.send({ success: false, message: '找不到資料' })
    } else {
      res.status(500)
      res.send({ success: false, message: '伺服器發生錯誤' })
    }
    console.log(error)
  }
})
```

### 修改
修改使用者資料  
```js
app.patch('/users/:id', async (req, res) => {
  // 拒絕不是 json 的資料格式
  if (!req.headers['content-type'].includes('application/json')) {
    // 回傳錯誤狀態碼
    res.status(400)
    res.send({ success: false, message: '格式不符' })
    return
  }

  try {
    // findByIdAndUpdate 預設回來的 result 是更新前的資料
    // 加上 new true 後可以回來新的資料
    const result = await db.users.findByIdAndUpdate(req.params.id, req.body, { new: true })
    delete result.password
    res.status(200)
    res.send({
      success: true,
      message: '',
      id: result.id,
      name: result.name,
      account: result.account,
      email: result.email
    })
  } catch (error) {
    // 若 ID 格式不是 mongodb 格式
    if (error.name === 'CastError') {
      res.status(404)
      res.send({ success: false, message: '找不到資料' })
    } else {
      res.status(500)
      res.send({ success: false, message: '伺服器發生錯誤' })
    }
  }
})
```

### 刪除
```js
app.delete('/users/:id', async (req, res) => {
  try {
    await db.users.findByIdAndDelete(req.params.id)
    if (result === null) {
      res.status(404)
      res.send({ success: false, message: '找不到資料' })
    } else {
      res.status(200)
      res.send({ success: true, message: '' })
    }
  } catch (error) {
    // 若 ID 格式不是 mongodb 格式
    if (error.name === 'CastError') {
      res.status(404)
      res.send({ success: false, message: '找不到資料' })
    } else {
      res.status(500)
      res.send({ success: false, message: '伺服器發生錯誤' })
    }
  }
})
```

:::warning 作業
規劃並建立一個商品庫存 RESTful API
- 資料欄位
  - `name` 商品名稱
  - `price` 商品價格
  - `description` 商品說明
  - `count` 商品庫存量

- 新增
  - 請求方式為 **POST**
  - 路徑為 `/products`
  - 只接受 `application/json` 格式
    ```js
    {
      "name": "",
      "price": 0,
      "description": "",
      "count": 0
    }
    ```
  - 回傳相應狀態碼、是否成功、失敗訊息及商品資料，資料格式為 JSON
    ```js
    {
      "success": true,
      "message": "",
      "id": "",
      "name": "",
      "price": 0,
      "description": "",
      "count": 0
    }
    ```

- 修改
  - 請求方式為 **PATCH**
  - 能以 ID 修改庫存量、名稱、說明及價格
  - 路徑為 `/products/id`，以 param 判斷要修改的項目
  - 只接受 `application/json` 格式，JSON 的欄位是要修改的欄位，值是要修改的資料
    ```js
    {
      "name": ""
    }
    ```
  - 回傳相應狀態碼、是否成功、失敗訊息，資料格式為 JSON
    ```js
    {
      "success": true,
      "message": "",
    }
    ```

- 刪除
  - 請求方式為 **DELETE**
  - 路徑為 `/products/id`
  - 只接受 `application/json` 格式，`id` 是商品 ID
  - 回傳相應狀態碼、是否成功、失敗訊息，資料格式為 JSON
    ```js
    {
      "success": true,
      "message": "",
    }
    ```

- 查詢單個商品
  - 請求方式為 **GET**
  - 路徑為 `/products/id`
  - 回傳相應狀態碼、是否成功、失敗訊息，資料格式為 JSON
    ```js
    {
      "success": true,
      "message": "",
      "id": ""
      "name": "",
      "price": 0,
      "description": "",
      "count": 0,
    }
    ```

- 查詢所有商品
  - 請求方式為 **GET**
  - 路徑為 `/products`
  - 回傳相應狀態碼、是否成功、失敗訊息，資料格式為 JSON
    ```js
    {
      "success": true,
      "message": "",
      "products": [
        {
          "name": "",
          "price": 0,
          "description": "",
          "count": 0
        }
        // 其他商品...
      ]
    }
    ```

- 搜尋商品
  - 請求方式為 **GET**
  - 路徑為 `/products`
  - 以 `query` 來查詢商品，提供 `price_gte` (價格大於等於) 和 `price_lte` (價格小於等於) 兩種
  - 回傳相應狀態碼、是否成功、失敗訊息，資料格式為 JSON
    ```js
    {
      "success": true,
      "message": "",
      "products": [
        {
          "name": "",
          "price": 0,
          "description": "",
          "count": 0
        }
        // 其他商品...
      ]
    }
    ```
:::

## MVC 式寫法
`Model-View-Controller` 是一種設計模式，作法是將程式分割成以下三個元件  
- `Model` 模型，有存取資料庫的權利
- `View` 視圖，資料顯示
- `Controller` 控制器，控制程式流程，對事件做出回應，包括使用者行為和資料改變

<img src="/F2E-book/images/ch27/MVC Express.png" height="300" style="margin: 10px 0;">  

使用 MVC 架構改寫 API，將程式的結構更加直覺化，也將修改與功能擴充簡化，提高可用性  

### 檔案結構
依照 MVC 的功能區分資料夾，資料夾內再依資料區分檔案
```
.
├── controllers
│   └── users.js
├── models
│   └── users.js
├── routes
│   └── users.js
├── package.json
├── index.js (執行主體)
└── db.js (資料庫連接)
```

`index.js` 只需要放主要架構
```js
import express from 'express'
import bodyParser from 'body-parser'
import userRoutes from './routes/users.js'

const app = express()

app.use(bodyParser.json())

// 將路由分類，所有進到 /users 路徑的請求使用 users 類的路由
app.use('/users', userRoutes)
app.listen(3000)
```

`db.js` 也只需要放資料庫連接就好，因為 Schema 會另外寫在 Model
```js
import mongoose from 'mongoose'
import beautifyUnique from 'mongoose-beautiful-unique-validation'

mongoose.connect('mongodb://127.0.0.1:27017/mvc', { useNewUrlParser: true, useUnifiedTopology: true })
mongoose.plugin(beautifyUnique)
```

### Model
Models 直接沿用原本的就好
```js
const Schema = mongoose.Schema

const usersSchema = new Schema(
  {
    //...
  }
)

export const users = mongoose.model('users', usersSchema)
```

### Route
設定 users 路由
```js
import express from 'express'

import { createUser, getUsers, updateUser, deleteUser } from '../controllers/users.js'

const router = express.Router()

// 這裡最後的路徑會是 /users
router.post('/', createUser)

// 這裡最後的路徑會是 /users
router.get('/', getUsers)

// 這裡最後的路徑會是 /users/:id
router.patch('/:id', updateUser)

// 這裡最後的路徑會是 /users/:id
router.delete('/:id', deleteUser)

export default router
```

### Controller
Controller 只是把原本處理請求的程式獨立出來寫而已
```js
export const createUser = async (req, res) => {
  // ...
}
```